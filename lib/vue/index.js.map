{"version":3,"file":"index.js","sources":["../../src/src/core/utils.ts","../../src/src/core/cache.ts","../../src/src/core/environment.ts","../../src/src/core/store.ts","../../src/src/core/scroller.ts","../../src/src/core/resizer.ts","../../src/src/vue/ListItem.tsx","../../src/src/vue/utils.ts","../../src/src/vue/Virtualizer.tsx","../../src/src/vue/VList.tsx","../../src/src/vue/WindowVirtualizer.tsx"],"sourcesContent":["/** @internal */\r\nexport const NULL = null;\r\n\r\n/** @internal */\r\nexport const { min, max, abs, floor } = Math;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const clamp = (\r\n  value: number,\r\n  minValue: number,\r\n  maxValue: number\r\n): number => min(maxValue, max(minValue, value));\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const sort = <T extends number>(arr: readonly T[]): T[] => {\r\n  return [...arr].sort((a, b) => a - b);\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const microtask: (fn: () => void) => void =\r\n  typeof queueMicrotask === \"function\"\r\n    ? queueMicrotask\r\n    : (fn) => {\r\n        Promise.resolve().then(fn);\r\n      };\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const createPromise = <T = void>(): [Promise<T>, (arg: T) => void] => {\r\n  let resolve: ((arg: T) => void) | undefined;\r\n  const promise = new Promise<T>((res) => {\r\n    resolve = res;\r\n  });\r\n  return [promise, resolve!];\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const once = <T>(fn: () => T): (() => T) => {\r\n  let cache: T;\r\n\r\n  return () => {\r\n    if (fn) {\r\n      cache = fn();\r\n      fn = undefined!;\r\n    }\r\n    return cache;\r\n  };\r\n};\r\n","import { type InternalCacheSnapshot, type ItemsRange } from \"./types.js\";\r\nimport { clamp, floor, max, min, sort } from \"./utils.js\";\r\n\r\ntype Writeable<T> = {\r\n  -readonly [key in keyof T]: Writeable<T[key]>;\r\n};\r\n\r\n/** @internal */\r\nexport const UNCACHED = -1;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport type Cache = {\r\n  readonly _length: number;\r\n  // sizes\r\n  readonly _sizes: number[];\r\n  readonly _defaultItemSize: number;\r\n  // offsets\r\n  readonly _computedOffsetIndex: number;\r\n  readonly _offsets: number[];\r\n};\r\n\r\nconst fill = (array: number[], length: number, prepend?: boolean): number[] => {\r\n  const key = prepend ? \"unshift\" : \"push\";\r\n  for (let i = 0; i < length; i++) {\r\n    array[key](UNCACHED);\r\n  }\r\n  return array;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const getItemSize = (cache: Cache, index: number): number => {\r\n  const size = cache._sizes[index]!;\r\n  return size === UNCACHED ? cache._defaultItemSize : size;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const setItemSize = (\r\n  cache: Writeable<Cache>,\r\n  index: number,\r\n  size: number\r\n): boolean => {\r\n  const isInitialMeasurement = cache._sizes[index] === UNCACHED;\r\n  cache._sizes[index] = size;\r\n  // mark as dirty\r\n  cache._computedOffsetIndex = min(index, cache._computedOffsetIndex);\r\n  return isInitialMeasurement;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const getItemOffset = (\r\n  cache: Writeable<Cache>,\r\n  index: number\r\n): number => {\r\n  if (!cache._length) return 0;\r\n  if (cache._computedOffsetIndex >= index) {\r\n    return cache._offsets[index]!;\r\n  }\r\n\r\n  if (cache._computedOffsetIndex < 0) {\r\n    // first offset must be 0 to avoid returning NaN, which can cause infinite rerender.\r\n    // https://github.com/inokawa/virtua/pull/160\r\n    cache._offsets[0] = 0;\r\n    cache._computedOffsetIndex = 0;\r\n  }\r\n  let i = cache._computedOffsetIndex;\r\n  let top = cache._offsets[i]!;\r\n  while (i < index) {\r\n    top += getItemSize(cache, i);\r\n    cache._offsets[++i] = top;\r\n  }\r\n  // mark as measured\r\n  cache._computedOffsetIndex = index;\r\n  return top;\r\n};\r\n\r\n/**\r\n * Finds the index of an item in the cache whose computed offset is closest to the specified offset.\r\n *\r\n * @internal\r\n */\r\nexport const findIndex = (\r\n  cache: Cache,\r\n  offset: number,\r\n  low: number = 0,\r\n  high: number = cache._length - 1\r\n): number => {\r\n  // Find with binary search\r\n  let found: number = low;\r\n  while (low <= high) {\r\n    const mid = floor((low + high) / 2);\r\n    if (getItemOffset(cache, mid) <= offset) {\r\n      found = mid;\r\n      low = mid + 1;\r\n    } else {\r\n      high = mid - 1;\r\n    }\r\n  }\r\n  return clamp(found, 0, cache._length - 1);\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const computeRange = (\r\n  cache: Cache,\r\n  startOffset: number,\r\n  endOffset: number,\r\n  prevStartIndex: number\r\n): ItemsRange => {\r\n  // Clamp because prevStartIndex may exceed the limit when children decreased a lot after scrolling\r\n  prevStartIndex = min(prevStartIndex, cache._length - 1);\r\n\r\n  if (getItemOffset(cache, prevStartIndex) <= startOffset) {\r\n    // search forward\r\n    // start <= end, prevStartIndex <= start\r\n    const end = findIndex(cache, endOffset, prevStartIndex);\r\n    return [findIndex(cache, startOffset, prevStartIndex, end), end];\r\n  } else {\r\n    // search backward\r\n    // start <= end, start <= prevStartIndex\r\n    const start = findIndex(cache, startOffset, undefined, prevStartIndex);\r\n    return [start, findIndex(cache, endOffset, start)];\r\n  }\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const estimateDefaultItemSize = (\r\n  cache: Writeable<Cache>,\r\n  startIndex: number\r\n): number => {\r\n  let measuredCountBeforeStart = 0;\r\n  // This function will be called after measurement so measured size array must be longer than 0\r\n  const measuredSizes: number[] = [];\r\n  cache._sizes.forEach((s, i) => {\r\n    if (s !== UNCACHED) {\r\n      measuredSizes.push(s);\r\n      if (i < startIndex) {\r\n        measuredCountBeforeStart++;\r\n      }\r\n    }\r\n  });\r\n\r\n  // Discard cache for now\r\n  cache._computedOffsetIndex = -1;\r\n\r\n  // Calculate median\r\n  const sorted = sort(measuredSizes);\r\n  const len = sorted.length;\r\n  const mid = (len / 2) | 0;\r\n  const median =\r\n    len % 2 === 0 ? (sorted[mid - 1]! + sorted[mid]!) / 2 : sorted[mid]!;\r\n\r\n  const prevDefaultItemSize = cache._defaultItemSize;\r\n\r\n  // Calculate diff of unmeasured items before start\r\n  return (\r\n    ((cache._defaultItemSize = median) - prevDefaultItemSize) *\r\n    max(startIndex - measuredCountBeforeStart, 0)\r\n  );\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const initCache = (\r\n  length: number,\r\n  itemSize: number,\r\n  sizes?: readonly number[]\r\n): Cache => {\r\n  return {\r\n    _defaultItemSize: itemSize,\r\n    _sizes: sizes\r\n      ? // https://github.com/inokawa/virtua/issues/441\r\n        fill(\r\n          sizes.slice(0, min(length, sizes.length)),\r\n          max(0, length - sizes.length)\r\n        )\r\n      : fill([], length),\r\n    _length: length,\r\n    _computedOffsetIndex: -1,\r\n    _offsets: fill([], length + 1),\r\n  };\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const takeCacheSnapshot = (cache: Cache): InternalCacheSnapshot => {\r\n  return [cache._sizes.slice(), cache._defaultItemSize];\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const updateCacheLength = (\r\n  cache: Writeable<Cache>,\r\n  length: number,\r\n  isShift?: boolean\r\n): number => {\r\n  const diff = length - cache._length;\r\n\r\n  cache._computedOffsetIndex = isShift\r\n    ? // Discard cache for now\r\n      -1\r\n    : min(length - 1, cache._computedOffsetIndex);\r\n  cache._length = length;\r\n\r\n  if (diff > 0) {\r\n    // Added\r\n    fill(cache._offsets, diff);\r\n    fill(cache._sizes, diff, isShift);\r\n    return cache._defaultItemSize * diff;\r\n  } else {\r\n    // Removed\r\n    cache._offsets.splice(diff);\r\n    return (\r\n      isShift ? cache._sizes.splice(0, -diff) : cache._sizes.splice(diff)\r\n    ).reduce(\r\n      (acc, removed) =>\r\n        acc - (removed === UNCACHED ? cache._defaultItemSize : removed),\r\n      0\r\n    );\r\n  }\r\n};\r\n","import { once } from \"./utils.js\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const isBrowser = typeof window !== \"undefined\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const getDocumentElement = (doc: Document): HTMLElement =>\r\n  doc.documentElement;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const getCurrentDocument = (node: HTMLElement): Document =>\r\n  node.ownerDocument;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const getCurrentWindow = (doc: Document) => doc.defaultView!;\r\n\r\n/**\r\n * Currently, all browsers on iOS/iPadOS are WebKit, including WebView.\r\n * @internal\r\n */\r\nexport const isIOSWebKit = /*#__PURE__*/ once((): boolean => {\r\n  if (/iP(hone|od|ad)/.test(navigator.userAgent)) {\r\n    return true;\r\n  }\r\n  // Modern iPad detection (iPadOS 13+)\r\n  // iPadOS 13+ reports the same userAgent/platform information as macOS, to enable desktop sites.\r\n  // So we treat devices that have macOS like information but with touch support as iPadOS.\r\n  // https://stackoverflow.com/questions/57776001/how-to-detect-ipad-pro-as-ipad-using-javascript\r\n  return navigator.platform === \"MacIntel\" && navigator.maxTouchPoints > 0;\r\n});\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const isSmoothScrollSupported = /*#__PURE__*/ once((): boolean => {\r\n  return \"scrollBehavior\" in getDocumentElement(document).style;\r\n});\r\n","import {\r\n  initCache,\r\n  getItemSize as _getItemSize,\r\n  getItemOffset as _getItemOffset,\r\n  UNCACHED,\r\n  setItemSize,\r\n  estimateDefaultItemSize,\r\n  updateCacheLength,\r\n  computeRange,\r\n  takeCacheSnapshot,\r\n  findIndex,\r\n} from \"./cache.js\";\r\nimport { isIOSWebKit } from \"./environment.js\";\r\nimport type {\r\n  CacheSnapshot,\r\n  InternalCacheSnapshot,\r\n  ItemResize,\r\n  ItemsRange,\r\n} from \"./types.js\";\r\nimport { abs, max, min, NULL } from \"./utils.js\";\r\n\r\nconst MAX_INT_32 = 0x7fffffff;\r\n\r\nconst SCROLL_IDLE = 0;\r\nconst SCROLL_DOWN = 1;\r\nconst SCROLL_UP = 2;\r\ntype ScrollDirection =\r\n  | typeof SCROLL_IDLE\r\n  | typeof SCROLL_DOWN\r\n  | typeof SCROLL_UP;\r\n\r\nconst SCROLL_BY_NATIVE = 0;\r\nconst SCROLL_BY_MANUAL_SCROLL = 1;\r\nconst SCROLL_BY_SHIFT = 2;\r\ntype ScrollMode =\r\n  | typeof SCROLL_BY_NATIVE\r\n  | typeof SCROLL_BY_MANUAL_SCROLL\r\n  | typeof SCROLL_BY_SHIFT;\r\n\r\n/** @internal */\r\nexport const ACTION_SCROLL = 1;\r\n/** @internal */\r\nexport const ACTION_SCROLL_END = 2;\r\n/** @internal */\r\nexport const ACTION_ITEM_RESIZE = 3;\r\n/** @internal */\r\nexport const ACTION_VIEWPORT_RESIZE = 4;\r\n/** @internal */\r\nexport const ACTION_ITEMS_LENGTH_CHANGE = 5;\r\n/** @internal */\r\nexport const ACTION_START_OFFSET_CHANGE = 6;\r\n/** @internal */\r\nexport const ACTION_MANUAL_SCROLL = 7;\r\n/** @internal */\r\nexport const ACTION_BEFORE_MANUAL_SMOOTH_SCROLL = 8;\r\n\r\ntype Actions =\r\n  | [type: typeof ACTION_SCROLL, offset: number]\r\n  | [type: typeof ACTION_SCROLL_END, dummy?: void]\r\n  | [type: typeof ACTION_ITEM_RESIZE, entries: ItemResize[]]\r\n  | [type: typeof ACTION_VIEWPORT_RESIZE, size: number]\r\n  | [\r\n      type: typeof ACTION_ITEMS_LENGTH_CHANGE,\r\n      arg: [length: number, isShift?: boolean | undefined]\r\n    ]\r\n  | [type: typeof ACTION_START_OFFSET_CHANGE, offset: number]\r\n  | [type: typeof ACTION_MANUAL_SCROLL, dummy?: void]\r\n  | [type: typeof ACTION_BEFORE_MANUAL_SMOOTH_SCROLL, offset: number];\r\n\r\n/** @internal */\r\nexport const UPDATE_VIRTUAL_STATE = 0b0001;\r\n/** @internal */\r\nexport const UPDATE_SIZE_EVENT = 0b0010;\r\n/** @internal */\r\nexport const UPDATE_SCROLL_EVENT = 0b0100;\r\n/** @internal */\r\nexport const UPDATE_SCROLL_END_EVENT = 0b1000;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const getScrollSize = (store: VirtualStore): number => {\r\n  return max(store.$getTotalSize(), store.$getViewportSize());\r\n};\r\n\r\ntype Subscriber = (sync?: boolean) => void;\r\n\r\n/** @internal */\r\nexport type StateVersion =\r\n  number & {} /* hack for typescript to pretend as not falsy */;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport type VirtualStore = {\r\n  $dispose(): void;\r\n  $getStateVersion(): StateVersion;\r\n  $getCacheSnapshot(): CacheSnapshot;\r\n  $getRange(bufferSize?: number): ItemsRange;\r\n  $findItemIndex(offset: number): number;\r\n  $isUnmeasuredItem(index: number): boolean;\r\n  $getItemOffset(index: number, fromEnd?: boolean): number;\r\n  $getItemSize(index: number): number;\r\n  $getItemsLength(): number;\r\n  $getScrollOffset(): number;\r\n  $isScrolling(): boolean;\r\n  $getViewportSize(): number;\r\n  $getStartSpacerSize(): number;\r\n  $getTotalSize(): number;\r\n  _flushJump(): [number, boolean];\r\n  $subscribe(target: number, cb: Subscriber): () => void;\r\n  $update(...action: Actions): void;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const createVirtualStore = (\r\n  elementsCount: number,\r\n  itemSize: number = 40,\r\n  ssrCount: number = 0,\r\n  cacheSnapshot?: CacheSnapshot | undefined,\r\n  shouldAutoEstimateItemSize: boolean = false\r\n): VirtualStore => {\r\n  let isSSR = !!ssrCount;\r\n  let stateVersion: StateVersion = 1;\r\n  let viewportSize = 0;\r\n  let startSpacerSize = 0;\r\n  let scrollOffset = 0;\r\n  let jump = 0;\r\n  let pendingJump = 0;\r\n  let _flushedJump = 0;\r\n  let _scrollDirection: ScrollDirection = SCROLL_IDLE;\r\n  let _scrollMode: ScrollMode = SCROLL_BY_NATIVE;\r\n  let _frozenRange: ItemsRange | null = NULL;\r\n  let _prevRange: ItemsRange = [0, isSSR ? max(ssrCount - 1, 0) : -1];\r\n  let _totalMeasuredSize = 0;\r\n  let _isViewportMeasured = false;\r\n\r\n  const cache = initCache(\r\n    elementsCount,\r\n    cacheSnapshot\r\n      ? (cacheSnapshot as unknown as InternalCacheSnapshot)[1]\r\n      : itemSize,\r\n    cacheSnapshot && (cacheSnapshot as unknown as InternalCacheSnapshot)[0]\r\n  );\r\n  const subscribers = new Set<[number, Subscriber]>();\r\n  const getRelativeScrollOffset = () => scrollOffset - startSpacerSize;\r\n  const getVisibleOffset = () => getRelativeScrollOffset() + pendingJump + jump;\r\n  const getRange = (startOffset: number, endOffset: number) => {\r\n    return computeRange(cache, startOffset, endOffset, _prevRange[0]);\r\n  };\r\n  const getTotalSize = (): number => _getItemOffset(cache, cache._length);\r\n  const getItemOffset = (index: number, fromEnd?: boolean): number => {\r\n    const offset = _getItemOffset(cache, index) - pendingJump;\r\n    if (fromEnd) {\r\n      return getTotalSize() - offset - getItemSize(index);\r\n    }\r\n    return offset;\r\n  };\r\n  const getItemSize = (index: number): number => {\r\n    return _getItemSize(cache, index);\r\n  };\r\n  const isSizeEqual = (index: number, value: number = UNCACHED): boolean => {\r\n    return cache._sizes[index] === value;\r\n  };\r\n\r\n  const applyJump = (j: number) => {\r\n    if (j) {\r\n      if (\r\n        // In iOS WebKit browsers, updating scroll position will stop scrolling so it have to be deferred during scrolling.\r\n        (isIOSWebKit() && _scrollDirection !== SCROLL_IDLE) ||\r\n        // Before imperative smooth scrolling, we measure all items which may be visible during scrolling.\r\n        // However, especially in Firefox, there are rare cases where items resize while scrolling, which can stop smooth scrolling.\r\n        (_frozenRange && _scrollMode === SCROLL_BY_MANUAL_SCROLL)\r\n      ) {\r\n        pendingJump += j;\r\n      } else {\r\n        jump += j;\r\n      }\r\n    }\r\n  };\r\n\r\n  return {\r\n    $dispose: () => {\r\n      subscribers.clear();\r\n    },\r\n    $getStateVersion: () => stateVersion,\r\n    $getCacheSnapshot: () => {\r\n      return takeCacheSnapshot(cache) as unknown as CacheSnapshot;\r\n    },\r\n    $getRange: (bufferSize = 200) => {\r\n      if (!_isViewportMeasured || isSSR) {\r\n        // Return range for SSR, or return [0, -1] to render nothing, until the scroll offset and viewport size are determined.\r\n        // https://github.com/inokawa/virtua/issues/415\r\n        // https://github.com/inokawa/virtua/pull/818\r\n        return _prevRange;\r\n      }\r\n      let startIndex: number;\r\n      let endIndex: number;\r\n      if (_flushedJump) {\r\n        // Return previous range for consistent render until next scroll event comes in.\r\n        // And it must be clamped. https://github.com/inokawa/virtua/issues/597\r\n        [startIndex, endIndex] = _prevRange;\r\n      } else {\r\n        let startOffset = max(0, getVisibleOffset());\r\n        let endOffset = startOffset + viewportSize;\r\n\r\n        // For faster initial render pass, returns without buffer if measurement seems to be in progress.\r\n        if (!shouldAutoEstimateItemSize) {\r\n          bufferSize = max(0, bufferSize);\r\n\r\n          if (_scrollDirection !== SCROLL_DOWN) {\r\n            startOffset -= bufferSize;\r\n          }\r\n          if (_scrollDirection !== SCROLL_UP) {\r\n            endOffset += bufferSize;\r\n          }\r\n        }\r\n\r\n        [startIndex, endIndex] = _prevRange = getRange(\r\n          max(0, startOffset),\r\n          max(0, endOffset)\r\n        );\r\n        if (_frozenRange) {\r\n          startIndex = min(startIndex, _frozenRange[0]);\r\n          endIndex = max(endIndex, _frozenRange[1]);\r\n        }\r\n      }\r\n\r\n      return [max(startIndex, 0), min(endIndex, cache._length - 1)];\r\n    },\r\n    $findItemIndex: (offset) => findIndex(cache, offset - startSpacerSize),\r\n    $isUnmeasuredItem: isSizeEqual,\r\n    $getItemOffset: getItemOffset,\r\n    $getItemSize: getItemSize,\r\n    $getItemsLength: () => cache._length,\r\n    $getScrollOffset: () => scrollOffset,\r\n    $isScrolling: () => _scrollDirection !== SCROLL_IDLE,\r\n    $getViewportSize: () => viewportSize,\r\n    $getStartSpacerSize: () => startSpacerSize,\r\n    $getTotalSize: getTotalSize,\r\n    _flushJump: () => {\r\n      _flushedJump = jump;\r\n      jump = 0;\r\n      return [_flushedJump, _scrollMode === SCROLL_BY_SHIFT];\r\n    },\r\n    $subscribe: (target, cb) => {\r\n      const sub: [number, Subscriber] = [target, cb];\r\n      subscribers.add(sub);\r\n      return () => {\r\n        subscribers.delete(sub);\r\n      };\r\n    },\r\n    $update: (type, payload): void => {\r\n      let shouldFlushPendingJump: boolean | undefined;\r\n      let shouldSync: boolean | undefined;\r\n      let mutated = 0;\r\n\r\n      switch (type) {\r\n        case ACTION_SCROLL: {\r\n          if (payload === scrollOffset && _scrollMode === SCROLL_BY_NATIVE) {\r\n            // Ignore scroll events from different direction\r\n            break;\r\n          }\r\n\r\n          const flushedJump = _flushedJump;\r\n          _flushedJump = 0;\r\n\r\n          const delta = payload - scrollOffset;\r\n          const distance = abs(delta);\r\n\r\n          // Scroll event after jump compensation is not reliable because it may result in the opposite direction.\r\n          // The delta of artificial scroll may not be equal with the jump because it may be batched with other scrolls.\r\n          // And at least in latest Chrome/Firefox/Safari in 2023, setting value to scrollTop/scrollLeft can lose subpixel because its integer (sometimes float probably depending on dpr).\r\n          const isJustJumped = flushedJump && distance < abs(flushedJump) + 1;\r\n\r\n          // Scroll events are dispatched enough so it's ok to skip some of them.\r\n          if (\r\n            !isJustJumped &&\r\n            // Ignore until manual scrolling\r\n            _scrollMode === SCROLL_BY_NATIVE\r\n          ) {\r\n            _scrollDirection = delta < 0 ? SCROLL_UP : SCROLL_DOWN;\r\n          }\r\n\r\n          // TODO This will cause glitch in reverse infinite scrolling. Disable this until better solution is found.\r\n          // if (\r\n          //   pendingJump &&\r\n          //   ((_scrollDirection === SCROLL_UP &&\r\n          //     payload - max(pendingJump, 0) <= 0) ||\r\n          //     (_scrollDirection === SCROLL_DOWN &&\r\n          //       payload - min(pendingJump, 0) >= getScrollOffsetMax()))\r\n          // ) {\r\n          //   // Flush if almost reached to start or end\r\n          //   shouldFlushPendingJump = true;\r\n          // }\r\n\r\n          if (isSSR) {\r\n            isSSR = false;\r\n          }\r\n\r\n          scrollOffset = payload;\r\n          mutated = UPDATE_SCROLL_EVENT;\r\n\r\n          // Skip if offset is not changed\r\n          // Scroll offset may exceed min or max especially in Safari's elastic scrolling.\r\n          const relativeOffset = getRelativeScrollOffset();\r\n          if (\r\n            relativeOffset >= -viewportSize &&\r\n            relativeOffset <= getTotalSize()\r\n          ) {\r\n            mutated += UPDATE_VIRTUAL_STATE;\r\n\r\n            // Update synchronously if scrolled a lot\r\n            shouldSync = distance > viewportSize;\r\n          }\r\n          break;\r\n        }\r\n        case ACTION_SCROLL_END: {\r\n          mutated = UPDATE_SCROLL_END_EVENT;\r\n          if (_scrollDirection !== SCROLL_IDLE) {\r\n            shouldFlushPendingJump = true;\r\n            mutated += UPDATE_VIRTUAL_STATE;\r\n          }\r\n          _scrollDirection = SCROLL_IDLE;\r\n          _scrollMode = SCROLL_BY_NATIVE;\r\n          _frozenRange = NULL;\r\n          break;\r\n        }\r\n        case ACTION_ITEM_RESIZE: {\r\n          const updated = payload.filter(\r\n            ([index, size]) => !isSizeEqual(index, size)\r\n          );\r\n\r\n          // Skip if all items are cached and not updated\r\n          if (!updated.length) {\r\n            break;\r\n          }\r\n\r\n          // Calculate jump by resize to minimize junks in appearance\r\n          applyJump(\r\n            updated.reduce((acc, [index, size]) => {\r\n              if (\r\n                // Keep distance from end during shifting\r\n                _scrollMode === SCROLL_BY_SHIFT ||\r\n                (_frozenRange && _scrollMode === SCROLL_BY_MANUAL_SCROLL\r\n                  ? // https://github.com/inokawa/virtua/issues/380\r\n                    // https://github.com/inokawa/virtua/issues/758\r\n                    index < _frozenRange[0]\r\n                  : // Otherwise we should maintain visible position\r\n                    // Only apply jump if item is COMPLETELY above viewport (not just its top)\r\n                    // Use new size (not cached) so a growing item that will extend into\r\n                    // the viewport after resize doesn't trigger a jump\r\n                    getItemOffset(index) + max(size, getItemSize(index)) < getRelativeScrollOffset())\r\n              ) {\r\n                acc += size - getItemSize(index);\r\n              }\r\n              return acc;\r\n            }, 0)\r\n          );\r\n\r\n          // Update item sizes\r\n          for (const [index, size] of updated) {\r\n            const prevSize = getItemSize(index);\r\n            const isInitialMeasurement = setItemSize(cache, index, size);\r\n\r\n            if (shouldAutoEstimateItemSize) {\r\n              _totalMeasuredSize += isInitialMeasurement\r\n                ? size\r\n                : size - prevSize;\r\n            }\r\n          }\r\n\r\n          // Estimate initial item size from measured sizes\r\n          if (\r\n            shouldAutoEstimateItemSize &&\r\n            viewportSize &&\r\n            // If the total size is lower than the viewport, the item may be a empty state\r\n            _totalMeasuredSize > viewportSize\r\n          ) {\r\n            applyJump(\r\n              estimateDefaultItemSize(\r\n                cache,\r\n                findIndex(cache, getVisibleOffset())\r\n              )\r\n            );\r\n            shouldAutoEstimateItemSize = false;\r\n          }\r\n\r\n          mutated = UPDATE_VIRTUAL_STATE + UPDATE_SIZE_EVENT;\r\n\r\n          // Synchronous update is necessary in current design to minimize visible glitch in concurrent rendering.\r\n          // However this seems to be the main cause of the errors from ResizeObserver.\r\n          // https://github.com/inokawa/virtua/issues/470\r\n          //\r\n          // And in React, synchronous update with flushSync after asynchronous update will overtake the asynchronous one.\r\n          // If items resize happens just after scroll, race condition can occur depending on implementation.\r\n          shouldSync = true;\r\n          break;\r\n        }\r\n        case ACTION_VIEWPORT_RESIZE: {\r\n          if (viewportSize !== payload) {\r\n            if (!viewportSize) {\r\n              _isViewportMeasured = shouldSync = true;\r\n            }\r\n            viewportSize = payload;\r\n            mutated = UPDATE_VIRTUAL_STATE + UPDATE_SIZE_EVENT;\r\n          }\r\n          break;\r\n        }\r\n        case ACTION_ITEMS_LENGTH_CHANGE: {\r\n          if (payload[1]) {\r\n            applyJump(updateCacheLength(cache, payload[0], true));\r\n            _scrollMode = SCROLL_BY_SHIFT;\r\n            mutated = UPDATE_VIRTUAL_STATE;\r\n          } else {\r\n            updateCacheLength(cache, payload[0]);\r\n            // https://github.com/inokawa/virtua/issues/552\r\n            // https://github.com/inokawa/virtua/issues/557\r\n            mutated = UPDATE_VIRTUAL_STATE;\r\n          }\r\n          break;\r\n        }\r\n        case ACTION_START_OFFSET_CHANGE: {\r\n          startSpacerSize = payload;\r\n          break;\r\n        }\r\n        case ACTION_MANUAL_SCROLL: {\r\n          _scrollMode = SCROLL_BY_MANUAL_SCROLL;\r\n          break;\r\n        }\r\n        case ACTION_BEFORE_MANUAL_SMOOTH_SCROLL: {\r\n          _frozenRange = getRange(payload, payload + viewportSize);\r\n          mutated = UPDATE_VIRTUAL_STATE;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (mutated) {\r\n        stateVersion = (stateVersion & MAX_INT_32) + 1;\r\n\r\n        if (shouldFlushPendingJump && pendingJump) {\r\n          jump += pendingJump;\r\n          pendingJump = 0;\r\n        }\r\n\r\n        subscribers.forEach(([target, cb]) => {\r\n          // Early return to skip React's computation\r\n          if (!(mutated & target)) {\r\n            return;\r\n          }\r\n          // https://github.com/facebook/react/issues/25191\r\n          // https://github.com/facebook/react/blob/a5fc797db14c6e05d4d5c4dbb22a0dd70d41f5d5/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1443-L1447\r\n          cb(shouldSync);\r\n        });\r\n      }\r\n    },\r\n  };\r\n};\r\n","import {\r\n  getCurrentDocument,\r\n  getCurrentWindow,\r\n  getDocumentElement,\r\n  isIOSWebKit,\r\n  isSmoothScrollSupported,\r\n} from \"./environment.js\";\r\nimport {\r\n  ACTION_SCROLL,\r\n  type VirtualStore,\r\n  ACTION_SCROLL_END,\r\n  UPDATE_SIZE_EVENT,\r\n  ACTION_MANUAL_SCROLL,\r\n  ACTION_BEFORE_MANUAL_SMOOTH_SCROLL,\r\n  ACTION_START_OFFSET_CHANGE,\r\n} from \"./store.js\";\r\nimport { type ScrollToIndexOpts } from \"./types.js\";\r\nimport { clamp, createPromise, microtask, NULL } from \"./utils.js\";\r\n\r\nconst timeout = setTimeout;\r\n\r\nconst debounce = <T extends () => void>(fn: T, ms: number) => {\r\n  let id: ReturnType<typeof setTimeout> | undefined | null;\r\n\r\n  const cancel = () => {\r\n    if (id != NULL) {\r\n      clearTimeout(id);\r\n    }\r\n  };\r\n  const debouncedFn = () => {\r\n    cancel();\r\n    id = timeout(() => {\r\n      id = NULL;\r\n      fn();\r\n    }, ms);\r\n  };\r\n  debouncedFn._cancel = cancel;\r\n  return debouncedFn;\r\n};\r\n\r\n/**\r\n * scrollTop/scrollLeft can be negative value under certain styles.\r\n * - direction: rtl https://github.com/othree/jquery.rtl-scroll-type\r\n * - writing-mode   https://people.igalia.com/fwang/scrollable-elements-in-non-default-writing-modes/\r\n * - flex-direction: column-reverse/row-reverse\r\n *\r\n * top/left bottom/right\r\n * 0        100          spec compliant bottom/right overflow, or possibly top/left overflow in Chrome earlier than v85\r\n * -100     0            spec compliant top/left overflow\r\n * https://drafts.csswg.org/cssom-view/#scroll-an-element\r\n */\r\nconst normalizeScrollOffset = (offset: number, isNegative: boolean): number => {\r\n  return isNegative ? -offset : offset;\r\n};\r\n\r\nconst createScrollObserver = (\r\n  store: VirtualStore,\r\n  viewport: HTMLElement | Window,\r\n  isHorizontal: boolean,\r\n  getScrollOffset: () => number,\r\n  updateScrollOffset: (\r\n    value: number,\r\n    shift: boolean,\r\n    isMomentumScrolling: boolean\r\n  ) => void,\r\n  getStartOffset?: () => number\r\n) => {\r\n  const now = Date.now;\r\n\r\n  let lastScrollTime = 0;\r\n  let wheeling = false;\r\n  let touching = false;\r\n  let justTouchEnded = false;\r\n  let stillMomentumScrolling = false;\r\n\r\n  const onScrollEnd = debounce(() => {\r\n    if (wheeling || touching) {\r\n      wheeling = false;\r\n\r\n      // Wait while wheeling or touching\r\n      onScrollEnd();\r\n      return;\r\n    }\r\n\r\n    justTouchEnded = false;\r\n\r\n    store.$update(ACTION_SCROLL_END);\r\n  }, 150);\r\n\r\n  const onScroll = () => {\r\n    lastScrollTime = now();\r\n\r\n    if (justTouchEnded) {\r\n      stillMomentumScrolling = true;\r\n    }\r\n\r\n    if (getStartOffset) {\r\n      store.$update(ACTION_START_OFFSET_CHANGE, getStartOffset());\r\n    }\r\n    store.$update(ACTION_SCROLL, getScrollOffset());\r\n\r\n    onScrollEnd();\r\n  };\r\n\r\n  // Infer scroll state also from wheel events\r\n  // Sometimes scroll events do not fire when frame dropped even if the visual have been already scrolled\r\n  const onWheel = ((e: WheelEvent) => {\r\n    if (\r\n      wheeling ||\r\n      // Scroll start should be detected with scroll event\r\n      !store.$isScrolling() ||\r\n      // Probably a pinch-to-zoom gesture\r\n      e.ctrlKey\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const timeDelta = now() - lastScrollTime;\r\n    if (\r\n      // Check if wheel event occurs some time after scrolling\r\n      150 > timeDelta &&\r\n      50 < timeDelta &&\r\n      // Get delta before checking deltaMode for firefox behavior\r\n      // https://github.com/w3c/uievents/issues/181#issuecomment-392648065\r\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1392460#c34\r\n      (isHorizontal ? e.deltaX : e.deltaY)\r\n    ) {\r\n      wheeling = true;\r\n    }\r\n  }) as (e: Event) => void; // FIXME type error. why only here?\r\n\r\n  const onTouchStart = () => {\r\n    touching = true;\r\n    justTouchEnded = stillMomentumScrolling = false;\r\n  };\r\n  const onTouchEnd = () => {\r\n    touching = false;\r\n    if (isIOSWebKit()) {\r\n      justTouchEnded = true;\r\n    }\r\n  };\r\n\r\n  viewport.addEventListener(\"scroll\", onScroll);\r\n  viewport.addEventListener(\"wheel\", onWheel, { passive: true });\r\n  viewport.addEventListener(\"touchstart\", onTouchStart, { passive: true });\r\n  viewport.addEventListener(\"touchend\", onTouchEnd, { passive: true });\r\n\r\n  return {\r\n    _dispose: () => {\r\n      viewport.removeEventListener(\"scroll\", onScroll);\r\n      viewport.removeEventListener(\"wheel\", onWheel);\r\n      viewport.removeEventListener(\"touchstart\", onTouchStart);\r\n      viewport.removeEventListener(\"touchend\", onTouchEnd);\r\n      onScrollEnd._cancel();\r\n    },\r\n    _fixScrollJump: () => {\r\n      const [jump, shift] = store._flushJump();\r\n      if (!jump) return;\r\n      updateScrollOffset(jump, shift, stillMomentumScrolling);\r\n      stillMomentumScrolling = false;\r\n\r\n      if (shift && store.$getViewportSize() > store.$getTotalSize()) {\r\n        // In this case applying jump may not cause scroll.\r\n        // Current logic expects scroll event occurs after applying jump so we dispatch it manually.\r\n        store.$update(ACTION_SCROLL, getScrollOffset());\r\n      }\r\n    },\r\n  };\r\n};\r\n\r\ntype ScrollObserver = ReturnType<typeof createScrollObserver>;\r\n\r\ntype ScheduleScrollFunction = (\r\n  getTargetOffset: () => number,\r\n  smooth?: boolean\r\n) => Promise<void>;\r\n\r\nconst createScrollScheduler = (\r\n  store: VirtualStore,\r\n  initialized: () => Promise<boolean>,\r\n  scroll: (offset: number, smooth?: boolean) => void\r\n): [scroll: ScheduleScrollFunction, cancel: () => void] => {\r\n  let cancelScroll: (() => void) | undefined;\r\n\r\n  // The given offset will be clamped by browser\r\n  // https://drafts.csswg.org/cssom-view/#dom-element-scrolltop\r\n  return [\r\n    async (getTargetOffset, smooth) => {\r\n      // Wait for element assign. The element may be undefined if scrollRef prop is used and scroll is scheduled on mount.\r\n      // https://github.com/inokawa/virtua/pull/733\r\n      // https://github.com/inokawa/virtua/pull/750\r\n      if (!(await initialized())) {\r\n        return;\r\n      }\r\n\r\n      if (cancelScroll) {\r\n        // Cancel waiting scrollTo\r\n        cancelScroll();\r\n      }\r\n\r\n      const waitForMeasurement = (): [Promise<boolean>, () => void] => {\r\n        // Wait for the scroll destination items to be measured.\r\n        // The measurement will be done asynchronously and the timing is not predictable so we use promise.\r\n        const [promise, resolve] = createPromise<boolean>();\r\n        cancelScroll = () => {\r\n          resolve(false);\r\n        };\r\n\r\n        // Resize event may not happen when the window/tab is not visible, or during browser back in Safari.\r\n        // We have to wait for the initial measurement to avoid failing imperative scroll on mount.\r\n        // https://github.com/inokawa/virtua/issues/450\r\n        if (store.$getViewportSize()) {\r\n          // Cancel when items around scroll destination completely measured\r\n          timeout(cancelScroll, 150);\r\n        }\r\n        return [\r\n          promise,\r\n          store.$subscribe(UPDATE_SIZE_EVENT, () => {\r\n            resolve(true);\r\n          }),\r\n        ];\r\n      };\r\n\r\n      if (smooth && isSmoothScrollSupported()) {\r\n        store.$update(ACTION_BEFORE_MANUAL_SMOOTH_SCROLL, getTargetOffset());\r\n\r\n        // https://github.com/inokawa/virtua/issues/590\r\n        microtask(async () => {\r\n          while (true) {\r\n            let done = true;\r\n            for (let [i, end] = store.$getRange(); i <= end; i++) {\r\n              if (store.$isUnmeasuredItem(i)) {\r\n                done = false;\r\n                break;\r\n              }\r\n            }\r\n            if (done) {\r\n              break;\r\n            }\r\n            const [promise, unsubscribe] = waitForMeasurement();\r\n\r\n            try {\r\n              if (!(await promise)) {\r\n                // canceled\r\n                return;\r\n              }\r\n            } finally {\r\n              unsubscribe();\r\n            }\r\n          }\r\n\r\n          store.$update(ACTION_MANUAL_SCROLL);\r\n          scroll(getTargetOffset(), smooth);\r\n        });\r\n      } else {\r\n        while (true) {\r\n          const [promise, unsubscribe] = waitForMeasurement();\r\n\r\n          try {\r\n            store.$update(ACTION_MANUAL_SCROLL);\r\n            scroll(getTargetOffset());\r\n\r\n            if (!(await promise)) {\r\n              // canceled or finished\r\n              return;\r\n            }\r\n          } finally {\r\n            unsubscribe();\r\n          }\r\n        }\r\n      }\r\n    },\r\n    () => {\r\n      cancelScroll && cancelScroll();\r\n    },\r\n  ];\r\n};\r\n\r\ninterface Scroller<T extends HTMLElement | void> {\r\n  $observe: (containerElement: HTMLElement, viewport: T) => void;\r\n  $dispose(): void;\r\n  $fixScrollJump: () => void;\r\n  $isNegative(): boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const createScroller = (\r\n  store: VirtualStore,\r\n  isHorizontal: boolean\r\n): Scroller<HTMLElement> & {\r\n  $scrollTo: (offset: number) => void;\r\n  $scrollBy: (offset: number) => void;\r\n  $scrollToIndex: (index: number, opts?: ScrollToIndexOpts) => void;\r\n} => {\r\n  let viewportElement: HTMLElement | undefined;\r\n  let scrollObserver: ScrollObserver | undefined;\r\n  let initialized = createPromise<boolean>();\r\n  let isNegative = false;\r\n  const scrollOffsetKey = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\r\n  const overflowKey = isHorizontal ? \"overflowX\" : \"overflowY\";\r\n\r\n  const [scheduleScroll, cancelScroll] = createScrollScheduler(\r\n    store,\r\n    () => initialized[0],\r\n    (offset, smooth) => {\r\n      offset = normalizeScrollOffset(offset, isNegative);\r\n\r\n      if (smooth) {\r\n        viewportElement!.scrollTo({\r\n          [isHorizontal ? \"left\" : \"top\"]: offset,\r\n          behavior: \"smooth\",\r\n        });\r\n      } else {\r\n        viewportElement![scrollOffsetKey] = offset;\r\n      }\r\n    }\r\n  );\r\n\r\n  return {\r\n    $observe(_, viewport) {\r\n      viewportElement = viewport;\r\n\r\n      if (isHorizontal) {\r\n        isNegative = getComputedStyle(viewport).direction === \"rtl\";\r\n      }\r\n\r\n      scrollObserver = createScrollObserver(\r\n        store,\r\n        viewport,\r\n        isHorizontal,\r\n        () => normalizeScrollOffset(viewport[scrollOffsetKey], isNegative),\r\n        (jump, shift, isMomentumScrolling) => {\r\n          // If we update scroll position while touching on iOS, the position will be reverted.\r\n          // However iOS WebKit fires touch events only once at the beginning of momentum scrolling.\r\n          // That means we have no reliable way to confirm still touched or not if user touches more than once during momentum scrolling...\r\n          // This is a hack for the suspectable situations, inspired by https://github.com/prud/ios-overflow-scroll-to-top\r\n          if (isMomentumScrolling) {\r\n            const style = viewport.style;\r\n            const prev = style[overflowKey];\r\n            style[overflowKey] = \"hidden\";\r\n            timeout(() => {\r\n              style[overflowKey] = prev;\r\n            });\r\n          }\r\n\r\n          // Use absolute position not to exceed scrollable bounds\r\n          // https://github.com/inokawa/virtua/discussions/475\r\n          viewport[scrollOffsetKey] = normalizeScrollOffset(\r\n            store.$getScrollOffset() + jump,\r\n            isNegative\r\n          );\r\n          if (shift) {\r\n            // https://github.com/inokawa/virtua/issues/357\r\n            cancelScroll();\r\n          }\r\n        }\r\n      );\r\n\r\n      initialized[1](true);\r\n    },\r\n    $dispose() {\r\n      scrollObserver && scrollObserver._dispose();\r\n      initialized[1](false);\r\n      // https://github.com/inokawa/virtua/pull/765\r\n      initialized = createPromise();\r\n    },\r\n    $isNegative: () => isNegative,\r\n    $scrollTo(offset) {\r\n      scheduleScroll(() => offset);\r\n    },\r\n    $scrollBy(offset) {\r\n      offset += store.$getScrollOffset();\r\n      scheduleScroll(() => offset);\r\n    },\r\n    $scrollToIndex(index, { align, smooth, offset = 0 } = {}) {\r\n      index = clamp(index, 0, store.$getItemsLength() - 1);\r\n\r\n      if (align === \"nearest\") {\r\n        const itemOffset = store.$getItemOffset(index);\r\n        const scrollOffset = store.$getScrollOffset();\r\n\r\n        if (itemOffset < scrollOffset) {\r\n          align = \"start\";\r\n        } else if (\r\n          itemOffset + store.$getItemSize(index) >\r\n          scrollOffset + store.$getViewportSize()\r\n        ) {\r\n          align = \"end\";\r\n        } else {\r\n          // already completely visible\r\n          return;\r\n        }\r\n      }\r\n\r\n      scheduleScroll(() => {\r\n        return (\r\n          offset +\r\n          store.$getStartSpacerSize() +\r\n          store.$getItemOffset(index) +\r\n          (align === \"end\"\r\n            ? store.$getItemSize(index) - store.$getViewportSize()\r\n            : align === \"center\"\r\n            ? (store.$getItemSize(index) - store.$getViewportSize()) / 2\r\n            : 0)\r\n        );\r\n      }, smooth);\r\n    },\r\n    $fixScrollJump: () => {\r\n      scrollObserver && scrollObserver._fixScrollJump();\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const createWindowScroller = (\r\n  store: VirtualStore,\r\n  isHorizontal: boolean\r\n): Scroller<void> & {\r\n  $scrollToIndex: (index: number, opts?: ScrollToIndexOpts) => void;\r\n} => {\r\n  let containerElement: HTMLElement | undefined;\r\n  let scrollObserver: ScrollObserver | undefined;\r\n  let initialized = createPromise<boolean>();\r\n  let isNegative = false;\r\n  const scrollToKey = isHorizontal ? \"left\" : \"top\";\r\n\r\n  const [scheduleScroll] = createScrollScheduler(\r\n    store,\r\n    () => initialized[0],\r\n    (offset, smooth) => {\r\n      offset = normalizeScrollOffset(offset, isNegative);\r\n\r\n      const window = getCurrentWindow(getCurrentDocument(containerElement!));\r\n\r\n      if (smooth) {\r\n        window.scroll({\r\n          [scrollToKey]: offset,\r\n          behavior: \"smooth\",\r\n        });\r\n      } else {\r\n        window.scroll({\r\n          [scrollToKey]: offset,\r\n        });\r\n      }\r\n    }\r\n  );\r\n\r\n  const calcOffsetToViewport = (\r\n    node: HTMLElement,\r\n    viewport: HTMLElement,\r\n    window: Window,\r\n    isHorizontal: boolean,\r\n    offset: number = 0\r\n  ): number => {\r\n    // TODO calc offset only when it changes (maybe impossible)\r\n    const offsetKey = isHorizontal ? \"offsetLeft\" : \"offsetTop\";\r\n    const offsetSum =\r\n      offset +\r\n      (isHorizontal && isNegative\r\n        ? window.innerWidth - node[offsetKey] - node.offsetWidth\r\n        : node[offsetKey]);\r\n\r\n    const parent = node.offsetParent;\r\n    if (node === viewport || !parent) {\r\n      return offsetSum;\r\n    }\r\n\r\n    return calcOffsetToViewport(\r\n      parent as HTMLElement,\r\n      viewport,\r\n      window,\r\n      isHorizontal,\r\n      offsetSum\r\n    );\r\n  };\r\n\r\n  return {\r\n    $observe(container) {\r\n      containerElement = container;\r\n      const scrollOffsetKey = isHorizontal ? \"scrollX\" : \"scrollY\";\r\n\r\n      const document = getCurrentDocument(container);\r\n      const window = getCurrentWindow(document);\r\n\r\n      if (isHorizontal) {\r\n        // Detect RTL document\r\n        isNegative =\r\n          getComputedStyle(getDocumentElement(document)).direction === \"rtl\";\r\n      }\r\n\r\n      scrollObserver = createScrollObserver(\r\n        store,\r\n        window,\r\n        isHorizontal,\r\n        () => normalizeScrollOffset(window[scrollOffsetKey], isNegative),\r\n        (jump, shift) => {\r\n          // TODO support case two window scrollers exist in the same view\r\n          if (shift) {\r\n            // Use absolute position not to exceed scrollable bounds\r\n            window.scroll({\r\n              [scrollToKey]: normalizeScrollOffset(\r\n                store.$getScrollOffset() + jump,\r\n                isNegative\r\n              ),\r\n            });\r\n          } else {\r\n            // Use window.scrollBy here, which causes less layout shift for some reason.\r\n            window.scrollBy({\r\n              [scrollToKey]: normalizeScrollOffset(jump, isNegative),\r\n            });\r\n          }\r\n        },\r\n        () =>\r\n          calcOffsetToViewport(container, document.body, window, isHorizontal)\r\n      );\r\n\r\n      initialized[1](true);\r\n    },\r\n    $dispose() {\r\n      scrollObserver && scrollObserver._dispose();\r\n      containerElement = undefined;\r\n      initialized[1](false);\r\n      // https://github.com/inokawa/virtua/pull/765\r\n      initialized = createPromise();\r\n    },\r\n    $isNegative: () => isNegative,\r\n    $fixScrollJump: () => {\r\n      scrollObserver && scrollObserver._fixScrollJump();\r\n    },\r\n    $scrollToIndex(index, { align, smooth, offset = 0 } = {}) {\r\n      if (!containerElement) return;\r\n\r\n      index = clamp(index, 0, store.$getItemsLength() - 1);\r\n\r\n      if (align === \"nearest\") {\r\n        const itemOffset = store.$getItemOffset(index);\r\n        const scrollOffset = store.$getScrollOffset();\r\n\r\n        if (itemOffset < scrollOffset) {\r\n          align = \"start\";\r\n        } else if (\r\n          itemOffset + store.$getItemSize(index) >\r\n          scrollOffset + store.$getViewportSize()\r\n        ) {\r\n          align = \"end\";\r\n        } else {\r\n          return;\r\n        }\r\n      }\r\n\r\n      const document = getCurrentDocument(containerElement);\r\n      const window = getCurrentWindow(document);\r\n      const html = getDocumentElement(document);\r\n      const getScrollbarSize = () =>\r\n        store.$getViewportSize() -\r\n        (isHorizontal ? html.clientWidth : html.clientHeight);\r\n\r\n      scheduleScroll(() => {\r\n        return (\r\n          offset +\r\n          // Calculate target scroll position including container's offset from document\r\n          calcOffsetToViewport(\r\n            containerElement!,\r\n            document.body,\r\n            window,\r\n            isHorizontal\r\n          ) +\r\n          // store._getStartSpacerSize() +\r\n          store.$getItemOffset(index) +\r\n          (align === \"end\"\r\n            ? store.$getItemSize(index) -\r\n              (store.$getViewportSize() - getScrollbarSize())\r\n            : align === \"center\"\r\n            ? (store.$getItemSize(index) -\r\n                (store.$getViewportSize() - getScrollbarSize())) /\r\n              2\r\n            : 0)\r\n        );\r\n      }, smooth);\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface GridScroller extends Scroller<HTMLElement> {\r\n  $scrollTo: (offsetX?: number, offsetY?: number) => void;\r\n  $scrollBy: (offsetX?: number, offsetY?: number) => void;\r\n  $scrollToIndex: (indexX?: number, indexY?: number) => void;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const createGridScroller = (\r\n  rowStore: VirtualStore,\r\n  colStore: VirtualStore\r\n): GridScroller => {\r\n  const rowScroller = createScroller(rowStore, false);\r\n  const colScroller = createScroller(colStore, true);\r\n  return {\r\n    $observe(container, viewport) {\r\n      rowScroller.$observe(container, viewport);\r\n      colScroller.$observe(container, viewport);\r\n    },\r\n    $dispose() {\r\n      rowScroller.$dispose();\r\n      colScroller.$dispose();\r\n    },\r\n    $isNegative: colScroller.$isNegative,\r\n    $scrollTo(row, col) {\r\n      if (row != null) {\r\n        rowScroller.$scrollTo(row);\r\n      }\r\n      if (col != null) {\r\n        colScroller.$scrollTo(col);\r\n      }\r\n    },\r\n    $scrollBy(row, col) {\r\n      if (row != null) {\r\n        rowScroller.$scrollBy(row);\r\n      }\r\n      if (col != null) {\r\n        colScroller.$scrollBy(col);\r\n      }\r\n    },\r\n    $scrollToIndex(row, col) {\r\n      if (row != null) {\r\n        rowScroller.$scrollToIndex(row);\r\n      }\r\n      if (col != null) {\r\n        colScroller.$scrollToIndex(col);\r\n      }\r\n    },\r\n    $fixScrollJump() {\r\n      rowScroller.$fixScrollJump();\r\n      colScroller.$fixScrollJump();\r\n    },\r\n  };\r\n};\r\n","import { getCurrentDocument, getCurrentWindow } from \"./environment.js\";\r\nimport {\r\n  ACTION_ITEM_RESIZE,\r\n  ACTION_VIEWPORT_RESIZE,\r\n  type VirtualStore,\r\n} from \"./store.js\";\r\nimport { type ItemResize } from \"./types.js\";\r\nimport { max, microtask, NULL } from \"./utils.js\";\r\n\r\nconst createResizeObserver = (cb: ResizeObserverCallback) => {\r\n  let ro: ResizeObserver | undefined;\r\n\r\n  return {\r\n    _observe(e: HTMLElement) {\r\n      // Initialize ResizeObserver lazily for SSR\r\n      // https://www.w3.org/TR/resize-observer/#intro\r\n      (\r\n        ro ||\r\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1491739\r\n        (ro = new (getCurrentWindow(getCurrentDocument(e)).ResizeObserver)(cb))\r\n      ).observe(e);\r\n    },\r\n    _unobserve(e: HTMLElement) {\r\n      ro!.unobserve(e);\r\n    },\r\n    _dispose() {\r\n      ro && ro.disconnect();\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport type ItemResizeObserver = (el: HTMLElement, i: number) => () => void;\r\n\r\ninterface ListResizer {\r\n  $observeRoot(viewportElement: HTMLElement): void;\r\n  $observeItem: ItemResizeObserver;\r\n  $dispose(): void;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const createResizer = (\r\n  store: VirtualStore,\r\n  isHorizontal: boolean\r\n): ListResizer => {\r\n  let viewportElement: HTMLElement | undefined;\r\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\r\n  const mountedIndexes = new WeakMap<Element, number>();\r\n\r\n  const resizeObserver = createResizeObserver((entries) => {\r\n    const resizes: ItemResize[] = [];\r\n    for (const { target, contentRect } of entries) {\r\n      // Skip zero-sized rects that may be observed under `display: none` style\r\n      if (!(target as HTMLElement).offsetParent) continue;\r\n\r\n      if (target === viewportElement) {\r\n        store.$update(ACTION_VIEWPORT_RESIZE, contentRect[sizeKey]);\r\n      } else {\r\n        const index = mountedIndexes.get(target);\r\n        if (index != NULL) {\r\n          resizes.push([index, contentRect[sizeKey]]);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (resizes.length) {\r\n      store.$update(ACTION_ITEM_RESIZE, resizes);\r\n    }\r\n  });\r\n\r\n  return {\r\n    $observeRoot(viewport: HTMLElement) {\r\n      resizeObserver._observe((viewportElement = viewport));\r\n    },\r\n    $observeItem: (el: HTMLElement, i: number) => {\r\n      mountedIndexes.set(el, i);\r\n      resizeObserver._observe(el);\r\n      return () => {\r\n        mountedIndexes.delete(el);\r\n        resizeObserver._unobserve(el);\r\n      };\r\n    },\r\n    $dispose: resizeObserver._dispose,\r\n  };\r\n};\r\n\r\ninterface WindowListResizer {\r\n  $observeRoot(container: HTMLElement): void;\r\n  $observeItem: ItemResizeObserver;\r\n  $dispose(): void;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const createWindowResizer = (\r\n  store: VirtualStore,\r\n  isHorizontal: boolean\r\n): WindowListResizer => {\r\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\r\n  const windowSizeKey = isHorizontal ? \"innerWidth\" : \"innerHeight\";\r\n  const mountedIndexes = new WeakMap<Element, number>();\r\n\r\n  const resizeObserver = createResizeObserver((entries) => {\r\n    const resizes: ItemResize[] = [];\r\n    for (const { target, contentRect } of entries) {\r\n      // Skip zero-sized rects that may be observed under `display: none` style\r\n      if (!(target as HTMLElement).offsetParent) continue;\r\n\r\n      const index = mountedIndexes.get(target);\r\n      if (index != NULL) {\r\n        resizes.push([index, contentRect[sizeKey]]);\r\n      }\r\n    }\r\n\r\n    if (resizes.length) {\r\n      store.$update(ACTION_ITEM_RESIZE, resizes);\r\n    }\r\n  });\r\n\r\n  let cleanupOnWindowResize: (() => void) | undefined;\r\n\r\n  return {\r\n    $observeRoot(container) {\r\n      const window = getCurrentWindow(getCurrentDocument(container));\r\n      const onWindowResize = () => {\r\n        store.$update(ACTION_VIEWPORT_RESIZE, window[windowSizeKey]);\r\n      };\r\n      window.addEventListener(\"resize\", onWindowResize);\r\n\r\n      // https://github.com/inokawa/virtua/issues/792\r\n      microtask(onWindowResize);\r\n\r\n      cleanupOnWindowResize = () => {\r\n        window.removeEventListener(\"resize\", onWindowResize);\r\n      };\r\n    },\r\n    $observeItem: (el: HTMLElement, i: number) => {\r\n      mountedIndexes.set(el, i);\r\n      resizeObserver._observe(el);\r\n      return () => {\r\n        mountedIndexes.delete(el);\r\n        resizeObserver._unobserve(el);\r\n      };\r\n    },\r\n    $dispose() {\r\n      cleanupOnWindowResize && cleanupOnWindowResize();\r\n      resizeObserver._dispose();\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const createGridResizer = (\r\n  rowStore: VirtualStore,\r\n  colStore: VirtualStore\r\n) => {\r\n  let viewportElement: HTMLElement | undefined;\r\n\r\n  const mountedIndexes = new WeakMap<\r\n    Element,\r\n    [rowIndex: number, colIndex: number]\r\n  >();\r\n\r\n  type CellSize = [height: number, width: number];\r\n  const maybeCachedRowIndexes = new Set<number>();\r\n  const maybeCachedColIndexes = new Set<number>();\r\n  const sizeCache = new Map<string, CellSize>();\r\n  const getKey = (rowIndex: number, colIndex: number): string =>\r\n    `${rowIndex}-${colIndex}`;\r\n\r\n  const resizeObserver = createResizeObserver((entries) => {\r\n    const resizedRows = new Set<number>();\r\n    const resizedCols = new Set<number>();\r\n    for (const {\r\n      target,\r\n      contentRect: { width, height },\r\n    } of entries) {\r\n      // Skip zero-sized rects that may be observed under `display: none` style\r\n      if (!(target as HTMLElement).offsetParent) continue;\r\n\r\n      if (target === viewportElement) {\r\n        rowStore.$update(ACTION_VIEWPORT_RESIZE, height);\r\n        colStore.$update(ACTION_VIEWPORT_RESIZE, width);\r\n      } else {\r\n        const cell = mountedIndexes.get(target);\r\n        if (cell) {\r\n          const [rowIndex, colIndex] = cell;\r\n          const key = getKey(rowIndex, colIndex);\r\n          const prevSize = sizeCache.get(key);\r\n          let rowResized: boolean | undefined;\r\n          let colResized: boolean | undefined;\r\n          if (!prevSize) {\r\n            rowResized = colResized = true;\r\n          } else {\r\n            if (prevSize[0] !== height) {\r\n              rowResized = true;\r\n            }\r\n            if (prevSize[1] !== width) {\r\n              colResized = true;\r\n            }\r\n          }\r\n          if (rowResized) {\r\n            resizedRows.add(rowIndex);\r\n          }\r\n          if (colResized) {\r\n            resizedCols.add(colIndex);\r\n          }\r\n          if (rowResized || colResized) {\r\n            sizeCache.set(key, [height, width]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (resizedRows.size) {\r\n      const heightResizes: ItemResize[] = [];\r\n      resizedRows.forEach((rowIndex) => {\r\n        let maxHeight = 0;\r\n        maybeCachedColIndexes.forEach((colIndex) => {\r\n          const size = sizeCache.get(getKey(rowIndex, colIndex));\r\n          if (size) {\r\n            maxHeight = max(maxHeight, size[0]);\r\n          }\r\n        });\r\n        if (maxHeight) {\r\n          heightResizes.push([rowIndex, maxHeight]);\r\n        }\r\n      });\r\n      rowStore.$update(ACTION_ITEM_RESIZE, heightResizes);\r\n    }\r\n    if (resizedCols.size) {\r\n      const widthResizes: ItemResize[] = [];\r\n      resizedCols.forEach((colIndex) => {\r\n        let maxWidth = 0;\r\n        maybeCachedRowIndexes.forEach((rowIndex) => {\r\n          const size = sizeCache.get(getKey(rowIndex, colIndex));\r\n          if (size) {\r\n            maxWidth = max(maxWidth, size[1]);\r\n          }\r\n        });\r\n        if (maxWidth) {\r\n          widthResizes.push([colIndex, maxWidth]);\r\n        }\r\n      });\r\n      colStore.$update(ACTION_ITEM_RESIZE, widthResizes);\r\n    }\r\n  });\r\n\r\n  return {\r\n    $observeRoot(viewport: HTMLElement) {\r\n      resizeObserver._observe((viewportElement = viewport));\r\n    },\r\n    $observeItem(el: HTMLElement, rowIndex: number, colIndex: number) {\r\n      mountedIndexes.set(el, [rowIndex, colIndex]);\r\n      maybeCachedRowIndexes.add(rowIndex);\r\n      maybeCachedColIndexes.add(colIndex);\r\n      resizeObserver._observe(el);\r\n      return () => {\r\n        mountedIndexes.delete(el);\r\n        resizeObserver._unobserve(el);\r\n      };\r\n    },\r\n    $resizeCols(cols: ItemResize[]) {\r\n      for (const [c] of cols) {\r\n        for (let r = 0; r < rowStore.$getItemsLength(); r++) {\r\n          sizeCache.delete(getKey(r, c));\r\n        }\r\n      }\r\n      colStore.$update(ACTION_ITEM_RESIZE, cols);\r\n    },\r\n    $resizeRows(rows: ItemResize[]) {\r\n      for (const [r] of rows) {\r\n        for (let c = 0; c < colStore.$getItemsLength(); c++) {\r\n          sizeCache.delete(getKey(r, c));\r\n        }\r\n      }\r\n      rowStore.$update(ACTION_ITEM_RESIZE, rows);\r\n    },\r\n    $dispose: resizeObserver._dispose,\r\n  };\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport type GridResizer = ReturnType<typeof createGridResizer>;\r\n","/** @jsxImportSource vue */\r\nimport {\r\n  ref,\r\n  defineComponent,\r\n  watch,\r\n  type StyleValue,\r\n  type PropType,\r\n  type VNode,\r\n  type NativeElements,\r\n  computed,\r\n  type Ref,\r\n} from \"vue\";\r\nimport {\r\n  type ItemResizeObserver,\r\n  type StateVersion,\r\n  type VirtualStore,\r\n} from \"../core/index.js\";\r\nimport { type ItemProps } from \"./utils.js\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const ListItem = /*#__PURE__*/ defineComponent({\r\n  props: {\r\n    _stateVersion: {\r\n      type: Object as PropType<Ref<StateVersion>>,\r\n      required: true,\r\n    },\r\n    _store: { type: Object as PropType<VirtualStore>, required: true },\r\n    _children: { type: Object as PropType<VNode>, required: true },\r\n    _resizer: {\r\n      type: Function as PropType<ItemResizeObserver>,\r\n      required: true,\r\n    },\r\n    _index: { type: Number, required: true },\r\n    _isHorizontal: { type: Boolean },\r\n    _isSSR: { type: Boolean },\r\n    _isNegative: { type: Boolean },\r\n    _as: { type: String as PropType<keyof NativeElements>, required: true },\r\n    _itemProps: Object as PropType<ReturnType<ItemProps>>,\r\n  },\r\n  setup(props) {\r\n    const elementRef = ref<HTMLDivElement>();\r\n\r\n    const offset = computed(\r\n      () =>\r\n        props._stateVersion.value &&\r\n        props._store.$getItemOffset(props._index, props._isNegative)\r\n    );\r\n    const hide = computed(\r\n      () =>\r\n        props._stateVersion.value &&\r\n        props._store.$isUnmeasuredItem(props._index)\r\n    );\r\n\r\n    // The index may be changed if elements are inserted to or removed from the start of props.children\r\n    watch(\r\n      () => elementRef.value && props._index,\r\n      (_, __, onCleanup) => {\r\n        onCleanup(props._resizer(elementRef.value!, props._index));\r\n      },\r\n      {\r\n        flush: \"post\",\r\n      }\r\n    );\r\n\r\n    return () => {\r\n      const {\r\n        _children: children,\r\n        _isHorizontal: isHorizontal,\r\n        _isSSR: isSSR,\r\n        _as: Element,\r\n      } = props;\r\n      const isHide = hide.value;\r\n\r\n      const { style: styleProp, ...rest } = props._itemProps ?? {};\r\n\r\n      const style: StyleValue = {\r\n        contain: \"layout style\",\r\n        position: isHide && isSSR ? undefined : \"absolute\",\r\n        [isHorizontal ? \"height\" : \"width\"]: \"100%\",\r\n        [isHorizontal ? \"top\" : \"left\"]: \"0px\",\r\n        [isHorizontal ? \"left\" : \"top\"]: offset.value + \"px\",\r\n        visibility: !isHide || isSSR ? undefined : \"hidden\",\r\n        ...styleProp,\r\n      };\r\n      if (isHorizontal) {\r\n        style.display = \"inline-flex\";\r\n      }\r\n\r\n      return (\r\n        <Element ref={elementRef} style={style} {...rest}>\r\n          {children}\r\n        </Element>\r\n      );\r\n    };\r\n  },\r\n});\r\n","import { type CSSProperties, type VNode } from \"vue\";\r\nimport { type ItemsRange } from \"../core/index.js\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const getKey = (e: VNode, i: number): Exclude<VNode[\"key\"], null> => {\r\n  const key = e.key;\r\n  return key != null ? key : \"_\" + i;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const isSameRange = (prev: ItemsRange, next: ItemsRange): boolean => {\r\n  return prev[0] === next[0] && prev[1] === next[1];\r\n};\r\n\r\nexport type ItemProps = (payload: {\r\n  item: any;\r\n  index: number;\r\n}) => { [key: string]: any; style?: CSSProperties; class?: string } | undefined;\r\n","/** @jsxImportSource vue */\r\nimport {\r\n  ref,\r\n  onMounted,\r\n  defineComponent,\r\n  onUnmounted,\r\n  type VNode,\r\n  watch,\r\n  type ComponentOptionsMixin,\r\n  type SlotsType,\r\n  type ComponentOptionsWithObjectProps,\r\n  type ComponentObjectPropsOptions,\r\n  type PropType,\r\n  type NativeElements,\r\n  computed,\r\n} from \"vue\";\r\nimport {\r\n  UPDATE_SCROLL_EVENT,\r\n  UPDATE_SCROLL_END_EVENT,\r\n  UPDATE_VIRTUAL_STATE,\r\n  createVirtualStore,\r\n  ACTION_ITEMS_LENGTH_CHANGE,\r\n  getScrollSize,\r\n  ACTION_START_OFFSET_CHANGE,\r\n  createResizer,\r\n  createScroller,\r\n  type ItemsRange,\r\n  type ScrollToIndexOpts,\r\n  sort,\r\n  type CacheSnapshot,\r\n} from \"../core/index.js\";\r\nimport { ListItem } from \"./ListItem.js\";\r\nimport { getKey, isSameRange, type ItemProps } from \"./utils.js\";\r\n\r\nexport interface VirtualizerHandle {\r\n  /**\r\n   * Get current {@link CacheSnapshot}.\r\n   */\r\n  readonly cache: CacheSnapshot;\r\n  /**\r\n   * Get current scrollTop, or scrollLeft if horizontal: true.\r\n   */\r\n  readonly scrollOffset: number;\r\n  /**\r\n   * Get current scrollHeight, or scrollWidth if horizontal: true.\r\n   */\r\n  readonly scrollSize: number;\r\n  /**\r\n   * Get current offsetHeight, or offsetWidth if horizontal: true.\r\n   */\r\n  readonly viewportSize: number;\r\n  /**\r\n   * Find nearest item index from offset.\r\n   * @param offset offset in pixels from the start of the scroll container\r\n   */\r\n  findItemIndex(offset: number): number;\r\n  /**\r\n   * Get item offset from start.\r\n   * @param index index of item\r\n   */\r\n  getItemOffset(index: number): number;\r\n  /**\r\n   * Get item size.\r\n   * @param index index of item\r\n   */\r\n  getItemSize(index: number): number;\r\n  /**\r\n   * Scroll to the item specified by index.\r\n   * @param index index of item\r\n   * @param opts options\r\n   */\r\n  scrollToIndex(index: number, opts?: ScrollToIndexOpts): void;\r\n  /**\r\n   * Scroll to the given offset.\r\n   * @param offset offset from start\r\n   */\r\n  scrollTo(offset: number): void;\r\n  /**\r\n   * Scroll by the given offset.\r\n   * @param offset offset from current position\r\n   */\r\n  scrollBy(offset: number): void;\r\n}\r\n\r\nconst props = {\r\n  /**\r\n   * The data items rendered by this component.\r\n   */\r\n  data: { type: Array, required: true },\r\n  /**\r\n   * Extra item space in pixels to render before/after the viewport. The minimum value is 0. Lower value will give better performance but you can increase to avoid showing blank items in fast scrolling.\r\n   * @defaultValue 200\r\n   */\r\n  bufferSize: Number,\r\n  /**\r\n   * Item size hint for unmeasured items in pixels. It will help to reduce scroll jump when items are measured if used properly.\r\n   *\r\n   * - If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.\r\n   * - If set, you can opt out estimation and use the value as initial item size.\r\n   */\r\n  itemSize: Number,\r\n  /**\r\n   * While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.\r\n   */\r\n  shift: Boolean,\r\n  /**\r\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\r\n   */\r\n  horizontal: Boolean,\r\n  /**\r\n   * The offset to the scrollable parent before virtualizer in pixels. If you put an element before virtualizer, you have to set its height to this prop.\r\n   */\r\n  startMargin: { type: Number, default: 0 },\r\n  /**\r\n   * A prop for SSR. If set, the specified amount of items will be mounted in the initial rendering regardless of the container size until hydrated. The minimum value is 0.\r\n   */\r\n  ssrCount: Number,\r\n  /**\r\n   * Reference to the scrollable element. The default will get the direct parent element of virtualizer.\r\n   */\r\n  scrollRef: Object as PropType<HTMLElement>,\r\n  /**\r\n   * Component or element type for container element.\r\n   * @defaultValue \"div\"\r\n   */\r\n  as: { type: String as PropType<keyof NativeElements>, default: \"div\" },\r\n  /**\r\n   * Component or element type for item element.\r\n   * @defaultValue \"div\"\r\n   */\r\n  item: { type: String as PropType<keyof NativeElements>, default: \"div\" },\r\n  /**\r\n   * A function that provides properties/attributes for item element\r\n   *\r\n   * **This prop will be merged into `item` prop in the future**\r\n   */\r\n  itemProps: Function as PropType<ItemProps>,\r\n  /**\r\n   * List of indexes that should be always mounted, even when off screen.\r\n   */\r\n  keepMounted: Array as PropType<readonly number[]>,\r\n  /**\r\n   * You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link VirtualizerHandle.cache}.\r\n   *\r\n   * **The length of items should be the same as when you take the snapshot, otherwise restoration may not work as expected.**\r\n   */\r\n  cache: Object as PropType<CacheSnapshot>,\r\n} satisfies ComponentObjectPropsOptions;\r\n\r\nexport const Virtualizer = /*#__PURE__*/ defineComponent({\r\n  props: props,\r\n  emits: [\"scroll\", \"scrollEnd\"],\r\n  setup(props, { emit, expose, slots }) {\r\n    let isSSR = !!props.ssrCount;\r\n\r\n    const isHorizontal = props.horizontal;\r\n    const containerRef = ref<HTMLDivElement>();\r\n    const store = createVirtualStore(\r\n      props.data.length,\r\n      props.itemSize,\r\n      props.ssrCount,\r\n      props.cache,\r\n      !props.itemSize\r\n    );\r\n    const resizer = createResizer(store, isHorizontal);\r\n    const scroller = createScroller(store, isHorizontal);\r\n\r\n    const stateVersion = ref(store.$getStateVersion());\r\n    store.$subscribe(UPDATE_VIRTUAL_STATE, () => {\r\n      stateVersion.value = store.$getStateVersion();\r\n    });\r\n    store.$subscribe(UPDATE_SCROLL_EVENT, () => {\r\n      emit(\"scroll\", store.$getScrollOffset());\r\n    });\r\n    store.$subscribe(UPDATE_SCROLL_END_EVENT, () => {\r\n      emit(\"scrollEnd\");\r\n    });\r\n\r\n    const range = computed<ItemsRange>((prev) => {\r\n      stateVersion.value;\r\n      const next = store.$getRange(props.bufferSize);\r\n      if (prev && isSameRange(prev, next)) {\r\n        return prev;\r\n      }\r\n      return next;\r\n    });\r\n    const isScrolling = computed(\r\n      () => stateVersion.value && store.$isScrolling()\r\n    );\r\n    const totalSize = computed(\r\n      () => stateVersion.value && store.$getTotalSize()\r\n    );\r\n\r\n    onMounted(() => {\r\n      isSSR = false;\r\n\r\n      // https://github.com/inokawa/virtua/issues/784\r\n      const container = containerRef.value!;\r\n      const raf = requestAnimationFrame(() => {\r\n        const assignScrollableElement = (e: HTMLElement) => {\r\n          resizer.$observeRoot(e);\r\n          scroller.$observe(container, e);\r\n        };\r\n        if (props.scrollRef) {\r\n          // parent's ref doesn't exist when onMounted is called\r\n          assignScrollableElement(props.scrollRef!);\r\n        } else {\r\n          assignScrollableElement(container.parentElement!);\r\n        }\r\n      });\r\n\r\n      onUnmounted(() => {\r\n        cancelAnimationFrame(raf);\r\n      });\r\n    });\r\n    onUnmounted(() => {\r\n      store.$dispose();\r\n      resizer.$dispose();\r\n      scroller.$dispose();\r\n    });\r\n\r\n    watch(\r\n      () => props.data.length,\r\n      (count) => {\r\n        store.$update(ACTION_ITEMS_LENGTH_CHANGE, [count, props.shift]);\r\n      }\r\n    );\r\n    watch(\r\n      () => props.startMargin,\r\n      (value) => {\r\n        store.$update(ACTION_START_OFFSET_CHANGE, value);\r\n      },\r\n      { immediate: true }\r\n    );\r\n\r\n    watch(\r\n      [stateVersion],\r\n      () => {\r\n        scroller.$fixScrollJump();\r\n      },\r\n      { flush: \"post\" }\r\n    );\r\n\r\n    expose({\r\n      get cache() {\r\n        return store.$getCacheSnapshot();\r\n      },\r\n      get scrollOffset() {\r\n        return store.$getScrollOffset();\r\n      },\r\n      get scrollSize() {\r\n        return getScrollSize(store);\r\n      },\r\n      get viewportSize() {\r\n        return store.$getViewportSize();\r\n      },\r\n      findItemIndex: store.$findItemIndex,\r\n      getItemOffset: store.$getItemOffset,\r\n      getItemSize: store.$getItemSize,\r\n      scrollToIndex: scroller.$scrollToIndex,\r\n      scrollTo: scroller.$scrollTo,\r\n      scrollBy: scroller.$scrollBy,\r\n    } satisfies VirtualizerHandle);\r\n\r\n    return () => {\r\n      const Element = props.as;\r\n      const ItemElement = props.item;\r\n\r\n      const total = totalSize.value;\r\n      const isNegative = scroller.$isNegative();\r\n\r\n      const items: VNode[] = [];\r\n\r\n      const renderItem = (i: number) => {\r\n        const e = slots.default({ item: props.data![i]!, index: i })[0]!;\r\n        return (\r\n          <ListItem\r\n            key={getKey(e, i)}\r\n            _stateVersion={stateVersion}\r\n            _store={store}\r\n            _resizer={resizer.$observeItem}\r\n            _index={i}\r\n            _children={e}\r\n            _isHorizontal={isHorizontal}\r\n            _isNegative={isNegative}\r\n            _isSSR={isSSR}\r\n            _as={ItemElement}\r\n            _itemProps={props.itemProps?.({ item: props.data![i]!, index: i })}\r\n          />\r\n        );\r\n      };\r\n\r\n      if (props.keepMounted) {\r\n        const mounted = new Set(props.keepMounted);\r\n        for (let [i, j] = range.value; i <= j; i++) {\r\n          mounted.add(i);\r\n        }\r\n        sort([...mounted]).forEach((index) => {\r\n          items.push(renderItem(index));\r\n        });\r\n      } else {\r\n        for (let [i, j] = range.value; i <= j; i++) {\r\n          items.push(renderItem(i));\r\n        }\r\n      }\r\n\r\n      return (\r\n        <Element\r\n          ref={containerRef}\r\n          style={{\r\n            contain: \"size style\", // https://github.com/inokawa/virtua/pull/775 https://github.com/inokawa/virtua/issues/800\r\n            overflowAnchor: \"none\", // opt out browser's scroll anchoring because it will conflict to scroll anchoring of virtualizer\r\n            flex: \"none\", // flex style can break layout\r\n            position: \"relative\",\r\n            width: isHorizontal ? total + \"px\" : \"100%\",\r\n            height: isHorizontal ? \"100%\" : total + \"px\",\r\n            pointerEvents: isScrolling.value ? \"none\" : undefined,\r\n          }}\r\n        >\r\n          {items}\r\n        </Element>\r\n      );\r\n    };\r\n  },\r\n} as ComponentOptionsWithObjectProps<\r\n  typeof props,\r\n  VirtualizerHandle,\r\n  {},\r\n  {},\r\n  {},\r\n  ComponentOptionsMixin,\r\n  ComponentOptionsMixin,\r\n  {\r\n    /**\r\n     * Callback invoked whenever scroll offset changes.\r\n     * @param offset Current scrollTop, or scrollLeft if horizontal: true.\r\n     */\r\n    scroll: (offset: number) => void;\r\n    /**\r\n     * Callback invoked when scrolling stops.\r\n     */\r\n    scrollEnd: () => void;\r\n  },\r\n  string,\r\n  {},\r\n  string,\r\n  SlotsType<{ default: (arg: { item: any; index: number }) => VNode[] }>\r\n>);\r\n","/** @jsxImportSource vue */\r\nimport {\r\n  defineComponent,\r\n  type ComponentOptionsMixin,\r\n  type SlotsType,\r\n  type ComponentOptionsWithObjectProps,\r\n  type ComponentObjectPropsOptions,\r\n  ref,\r\n  type VNode,\r\n  type PropType,\r\n} from \"vue\";\r\nimport { Virtualizer, type VirtualizerHandle } from \"./Virtualizer.js\";\r\nimport { type ItemProps } from \"./utils.js\";\r\nimport { type CacheSnapshot } from \"../core/index.js\";\r\n\r\ninterface VListHandle extends VirtualizerHandle {}\r\n\r\nconst props = {\r\n  /**\r\n   * The data items rendered by this component.\r\n   */\r\n  data: { type: Array, required: true },\r\n  /**\r\n   * Extra item space in pixels to render before/after the viewport. The minimum value is 0. Lower value will give better performance but you can increase to avoid showing blank items in fast scrolling.\r\n   * @defaultValue 200\r\n   */\r\n  bufferSize: Number,\r\n  /**\r\n   * Item size hint for unmeasured items in pixels. It will help to reduce scroll jump when items are measured if used properly.\r\n   *\r\n   * - If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.\r\n   * - If set, you can opt out estimation and use the value as initial item size.\r\n   */\r\n  itemSize: Number,\r\n  /**\r\n   * While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.\r\n   */\r\n  shift: Boolean,\r\n  /**\r\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\r\n   */\r\n  horizontal: Boolean,\r\n  /**\r\n   * A prop for SSR. If set, the specified amount of items will be mounted in the initial rendering regardless of the container size until hydrated. The minimum value is 0.\r\n   */\r\n  ssrCount: Number,\r\n  /**\r\n   * A function that provides properties/attributes for item element\r\n   *\r\n   * **This prop will be merged into `item` prop in the future**\r\n   */\r\n  itemProps: Function as PropType<ItemProps>,\r\n  /**\r\n   * List of indexes that should be always mounted, even when off screen.\r\n   */\r\n  keepMounted: Array as PropType<readonly number[]>,\r\n  /**\r\n   * You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link VirtualizerHandle.cache}.\r\n   *\r\n   * **The length of items should be the same as when you take the snapshot, otherwise restoration may not work as expected.**\r\n   */\r\n  cache: Object as PropType<CacheSnapshot>,\r\n} satisfies ComponentObjectPropsOptions;\r\n\r\nexport const VList = /*#__PURE__*/ defineComponent({\r\n  props: props,\r\n  emits: [\"scroll\", \"scrollEnd\"],\r\n  setup(props, { emit, expose, slots }) {\r\n    const horizontal = props.horizontal;\r\n\r\n    const onScroll = (offset: number) => {\r\n      emit(\"scroll\", offset);\r\n    };\r\n    const onScrollEnd = () => {\r\n      emit(\"scrollEnd\");\r\n    };\r\n\r\n    const handle = ref<InstanceType<typeof Virtualizer>>();\r\n\r\n    expose({\r\n      get cache() {\r\n        return handle.value!.cache;\r\n      },\r\n      get scrollOffset() {\r\n        return handle.value!.scrollOffset;\r\n      },\r\n      get scrollSize() {\r\n        return handle.value!.scrollSize;\r\n      },\r\n      get viewportSize() {\r\n        return handle.value!.viewportSize;\r\n      },\r\n      findItemIndex: (...args) => handle.value!.findItemIndex(...args),\r\n      getItemOffset: (...args) => handle.value!.getItemOffset(...args),\r\n      getItemSize: (...args) => handle.value!.getItemSize(...args),\r\n      scrollToIndex: (...args) => handle.value!.scrollToIndex(...args),\r\n      scrollTo: (...args) => handle.value!.scrollTo(...args),\r\n      scrollBy: (...args) => handle.value!.scrollBy(...args),\r\n    } satisfies VListHandle);\r\n\r\n    return () => {\r\n      return (\r\n        <div\r\n          style={{\r\n            display: horizontal ? \"inline-block\" : \"block\",\r\n            [horizontal ? \"overflowX\" : \"overflowY\"]: \"auto\",\r\n            contain: \"strict\",\r\n            width: \"100%\",\r\n            height: \"100%\",\r\n          }}\r\n        >\r\n          <Virtualizer\r\n            ref={handle}\r\n            data={props.data}\r\n            bufferSize={props.bufferSize}\r\n            itemSize={props.itemSize}\r\n            itemProps={props.itemProps}\r\n            shift={props.shift}\r\n            ssrCount={props.ssrCount}\r\n            horizontal={horizontal}\r\n            keepMounted={props.keepMounted}\r\n            cache={props.cache}\r\n            onScroll={onScroll}\r\n            onScrollEnd={onScrollEnd}\r\n          >\r\n            {slots}\r\n          </Virtualizer>\r\n        </div>\r\n      );\r\n    };\r\n  },\r\n} as ComponentOptionsWithObjectProps<\r\n  typeof props,\r\n  VListHandle,\r\n  {},\r\n  {},\r\n  {},\r\n  ComponentOptionsMixin,\r\n  ComponentOptionsMixin,\r\n  {\r\n    /**\r\n     * Callback invoked whenever scroll offset changes.\r\n     * @param offset Current scrollTop, or scrollLeft if horizontal: true.\r\n     */\r\n    scroll: (offset: number) => void;\r\n    /**\r\n     * Callback invoked when scrolling stops.\r\n     */\r\n    scrollEnd: () => void;\r\n  },\r\n  string,\r\n  {},\r\n  string,\r\n  SlotsType<{ default: (arg: { item: any; index: number }) => VNode[] }>\r\n>);\r\n","/** @jsxImportSource vue */\r\nimport {\r\n  ref,\r\n  onMounted,\r\n  defineComponent,\r\n  onUnmounted,\r\n  type VNode,\r\n  watch,\r\n  type ComponentOptionsMixin,\r\n  type SlotsType,\r\n  type ComponentOptionsWithObjectProps,\r\n  type ComponentObjectPropsOptions,\r\n  type PropType,\r\n  type NativeElements,\r\n  computed,\r\n} from \"vue\";\r\nimport {\r\n  UPDATE_SCROLL_END_EVENT,\r\n  UPDATE_VIRTUAL_STATE,\r\n  createVirtualStore,\r\n  ACTION_ITEMS_LENGTH_CHANGE,\r\n  UPDATE_SCROLL_EVENT,\r\n  createWindowResizer,\r\n  createWindowScroller,\r\n  type ItemsRange,\r\n  type ScrollToIndexOpts,\r\n  type CacheSnapshot,\r\n} from \"../core/index.js\";\r\nimport { ListItem } from \"./ListItem.js\";\r\nimport { getKey, isSameRange } from \"./utils.js\";\r\n\r\nexport interface WindowVirtualizerHandle {\r\n  /**\r\n   * Get current {@link CacheSnapshot}.\r\n   */\r\n  readonly cache: CacheSnapshot;\r\n  /**\r\n   * Get current scrollTop, or scrollLeft if horizontal: true.\r\n   */\r\n  readonly scrollOffset: number;\r\n  /**\r\n   * Get current offsetHeight, or offsetWidth if horizontal: true.\r\n   */\r\n  readonly viewportSize: number;\r\n  /**\r\n   * Find nearest item index from offset.\r\n   * @param offset offset in pixels from the start of the scroll container\r\n   */\r\n  findItemIndex(offset: number): number;\r\n  /**\r\n   * Get item offset from start.\r\n   * @param index index of item\r\n   */\r\n  getItemOffset(index: number): number;\r\n  /**\r\n   * Get item size.\r\n   * @param index index of item\r\n   */\r\n  getItemSize(index: number): number;\r\n  /**\r\n   * Scroll to the item specified by index.\r\n   * @param index index of item\r\n   * @param opts options\r\n   */\r\n  scrollToIndex(index: number, opts?: ScrollToIndexOpts): void;\r\n}\r\n\r\nconst props = {\r\n  /**\r\n   * The data items rendered by this component.\r\n   */\r\n  data: { type: Array, required: true },\r\n  /**\r\n   * Extra item space in pixels to render before/after the viewport. The minimum value is 0. Lower value will give better performance but you can increase to avoid showing blank items in fast scrolling.\r\n   * @defaultValue 200\r\n   */\r\n  bufferSize: Number,\r\n  /**\r\n   * Item size hint for unmeasured items in pixels. It will help to reduce scroll jump when items are measured if used properly.\r\n   *\r\n   * - If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.\r\n   * - If set, you can opt out estimation and use the value as initial item size.\r\n   */\r\n  itemSize: Number,\r\n  /**\r\n   * While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.\r\n   */\r\n  shift: Boolean,\r\n  /**\r\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\r\n   */\r\n  horizontal: Boolean,\r\n  /**\r\n   * Component or element type for container element.\r\n   * @defaultValue \"div\"\r\n   */\r\n  as: { type: String as PropType<keyof NativeElements>, default: \"div\" },\r\n  /**\r\n   * Component or element type for item element.\r\n   * @defaultValue \"div\"\r\n   */\r\n  item: { type: String as PropType<keyof NativeElements>, default: \"div\" },\r\n  /**\r\n   * You can restore cache by passing a {@link CacheSnapshot} on mount. This is useful when you want to restore scroll position after navigation. The snapshot can be obtained from {@link WindowVirtualizerHandle.cache}.\r\n   *\r\n   * **The length of items should be the same as when you take the snapshot, otherwise restoration may not work as expected.**\r\n   */\r\n  cache: Object as PropType<CacheSnapshot>,\r\n} satisfies ComponentObjectPropsOptions;\r\n\r\nexport const WindowVirtualizer = /*#__PURE__*/ defineComponent({\r\n  props,\r\n  emits: [\"scroll\", \"scrollEnd\"],\r\n  setup(props, { emit, slots, expose }) {\r\n    const isHorizontal = props.horizontal;\r\n    const containerRef = ref<HTMLDivElement>();\r\n    const store = createVirtualStore(\r\n      props.data.length,\r\n      props.itemSize,\r\n      undefined,\r\n      props.cache,\r\n      !props.itemSize\r\n    );\r\n    const resizer = createWindowResizer(store, isHorizontal);\r\n    const scroller = createWindowScroller(store, isHorizontal);\r\n\r\n    const stateVersion = ref(store.$getStateVersion());\r\n    store.$subscribe(UPDATE_VIRTUAL_STATE, () => {\r\n      stateVersion.value = store.$getStateVersion();\r\n    });\r\n    store.$subscribe(UPDATE_SCROLL_EVENT, () => {\r\n      // https://github.com/inokawa/virtua/discussions/580\r\n      emit(\"scroll\");\r\n    });\r\n    store.$subscribe(UPDATE_SCROLL_END_EVENT, () => {\r\n      emit(\"scrollEnd\");\r\n    });\r\n\r\n    const range = computed<ItemsRange>((prev) => {\r\n      stateVersion.value;\r\n      const next = store.$getRange(props.bufferSize);\r\n      if (prev && isSameRange(prev, next)) {\r\n        return prev;\r\n      }\r\n      return next;\r\n    });\r\n    const isScrolling = computed(\r\n      () => stateVersion.value && store.$isScrolling()\r\n    );\r\n    const totalSize = computed(\r\n      () => stateVersion.value && store.$getTotalSize()\r\n    );\r\n\r\n    onMounted(() => {\r\n      const el = containerRef.value;\r\n      if (!el) return;\r\n      resizer.$observeRoot(el);\r\n      scroller.$observe(el);\r\n    });\r\n    onUnmounted(() => {\r\n      store.$dispose();\r\n      resizer.$dispose();\r\n      scroller.$dispose();\r\n    });\r\n\r\n    watch(\r\n      () => props.data.length,\r\n      (count) => {\r\n        store.$update(ACTION_ITEMS_LENGTH_CHANGE, [count, props.shift]);\r\n      }\r\n    );\r\n\r\n    watch(\r\n      [stateVersion],\r\n      () => {\r\n        scroller.$fixScrollJump();\r\n      },\r\n      { flush: \"post\" }\r\n    );\r\n\r\n    expose({\r\n      get cache() {\r\n        return store.$getCacheSnapshot();\r\n      },\r\n      get scrollOffset() {\r\n        return store.$getScrollOffset();\r\n      },\r\n      get viewportSize() {\r\n        return store.$getViewportSize();\r\n      },\r\n      findItemIndex: store.$findItemIndex,\r\n      getItemOffset: store.$getItemOffset,\r\n      getItemSize: store.$getItemSize,\r\n      scrollToIndex: scroller.$scrollToIndex,\r\n    } satisfies WindowVirtualizerHandle);\r\n\r\n    return () => {\r\n      const Element = props.as;\r\n      const ItemElement = props.item;\r\n\r\n      const total = totalSize.value;\r\n      const isNegative = scroller.$isNegative();\r\n\r\n      const items: VNode[] = [];\r\n      for (let [i, j] = range.value; i <= j; i++) {\r\n        const e = slots.default({ item: props.data![i]!, index: i })[0]!;\r\n        items.push(\r\n          <ListItem\r\n            key={getKey(e, i)}\r\n            _stateVersion={stateVersion}\r\n            _store={store}\r\n            _resizer={resizer.$observeItem}\r\n            _index={i}\r\n            _children={e}\r\n            _isHorizontal={isHorizontal}\r\n            _isNegative={isNegative}\r\n            _as={ItemElement}\r\n          />\r\n        );\r\n      }\r\n\r\n      return (\r\n        <Element\r\n          ref={containerRef}\r\n          style={{\r\n            contain: \"size style\", // https://github.com/inokawa/virtua/pull/775 https://github.com/inokawa/virtua/issues/800\r\n            overflowAnchor: \"none\", // opt out browser's scroll anchoring because it will conflict to scroll anchoring of virtualizer\r\n            flex: \"none\", // flex style can break layout\r\n            position: \"relative\",\r\n            width: isHorizontal ? total + \"px\" : \"100%\",\r\n            height: isHorizontal ? \"100%\" : total + \"px\",\r\n            pointerEvents: isScrolling.value ? \"none\" : undefined,\r\n          }}\r\n        >\r\n          {items}\r\n        </Element>\r\n      );\r\n    };\r\n  },\r\n} as ComponentOptionsWithObjectProps<\r\n  typeof props,\r\n  void,\r\n  {},\r\n  {},\r\n  {},\r\n  ComponentOptionsMixin,\r\n  ComponentOptionsMixin,\r\n  {\r\n    /**\r\n     * Callback invoked whenever scroll offset changes.\r\n     */\r\n    scroll: () => void;\r\n    /**\r\n     * Callback invoked when scrolling stops.\r\n     */\r\n    scrollEnd: () => void;\r\n  },\r\n  string,\r\n  {},\r\n  string,\r\n  SlotsType<{ default: (arg: { item: any; index: number }) => VNode[] }>\r\n>);\r\n"],"names":["NULL","min","max","abs","floor","Math","clamp","value","minValue","maxValue","sort","arr","a","b","microtask","queueMicrotask","fn","Promise","resolve","then","createPromise","res","once","cache","undefined","fill","array","length","prepend","key","i","getItemSize","index","size","_sizes","_defaultItemSize","setItemSize","isInitialMeasurement","_computedOffsetIndex","getItemOffset","_length","_offsets","top","findIndex","offset","low","high","found","mid","updateCacheLength","isShift","diff","splice","reduce","acc","removed","getDocumentElement","doc","documentElement","getCurrentDocument","node","ownerDocument","getCurrentWindow","defaultView","isIOSWebKit","test","navigator","userAgent","platform","maxTouchPoints","isSmoothScrollSupported","document","style","createVirtualStore","elementsCount","itemSize","ssrCount","cacheSnapshot","shouldAutoEstimateItemSize","isSSR","stateVersion","viewportSize","startSpacerSize","scrollOffset","jump","pendingJump","_flushedJump","_scrollDirection","_scrollMode","_frozenRange","_prevRange","_totalMeasuredSize","_isViewportMeasured","initCache","sizes","slice","subscribers","Set","getRelativeScrollOffset","getVisibleOffset","getRange","startOffset","endOffset","computeRange","prevStartIndex","end","start","getTotalSize","_getItemOffset","getItemOffset$1","fromEnd","_getItemSize","isSizeEqual","UNCACHED","applyJump","j","$dispose","clear","$getStateVersion","$getCacheSnapshot","takeCacheSnapshot","$getRange","bufferSize","startIndex","endIndex","$findItemIndex","$isUnmeasuredItem","$getItemOffset","$getItemSize","$getItemsLength","$getScrollOffset","$isScrolling","$getViewportSize","$getStartSpacerSize","$getTotalSize","_flushJump","$subscribe","target","cb","sub","add","delete","$update","type","payload","shouldFlushPendingJump","shouldSync","mutated","flushedJump","delta","distance","relativeOffset","updated","filter","prevSize","estimateDefaultItemSize","measuredCountBeforeStart","measuredSizes","forEach","s","push","sorted","len","median","prevDefaultItemSize","UPDATE_VIRTUAL_STATE","timeout","setTimeout","normalizeScrollOffset","isNegative","createScrollObserver","store","viewport","isHorizontal","getScrollOffset","updateScrollOffset","getStartOffset","now","Date","lastScrollTime","wheeling","touching","justTouchEnded","stillMomentumScrolling","onScrollEnd","debounce","id","cancel","clearTimeout","debouncedFn","_cancel","onScroll","onWheel","e","ctrlKey","timeDelta","deltaX","deltaY","onTouchStart","onTouchEnd","addEventListener","passive","_dispose","removeEventListener","_fixScrollJump","shift","createScrollScheduler","initialized","scroll","cancelScroll","async","getTargetOffset","smooth","waitForMeasurement","promise","done","unsubscribe","createResizeObserver","ro","_observe","observe","_unobserve","unobserve","disconnect","ListItem","defineComponent","props","_stateVersion","Object","required","_store","_children","_resizer","Function","_index","Number","_isHorizontal","Boolean","_isSSR","_isNegative","_as","String","_itemProps","setup","elementRef","ref","computed","hide","watch","_","__","onCleanup","flush","children","Element","isHide","styleProp","rest","_a","contain","position","visibility","display","_createVNode","_mergeProps","prototype","toString","call","_isVNode","default","getKey","isSameRange","prev","next","Virtualizer","data","Array","horizontal","startMargin","scrollRef","as","item","itemProps","keepMounted","emits","emit","expose","slots","containerRef","resizer","createResizer","viewportElement","sizeKey","mountedIndexes","WeakMap","resizeObserver","entries","resizes","contentRect","offsetParent","get","$observeRoot","$observeItem","el","set","scroller","createScroller","scrollObserver","scrollOffsetKey","overflowKey","scheduleScroll","scrollTo","behavior","$observe","getComputedStyle","direction","isMomentumScrolling","$isNegative","$scrollTo","$scrollBy","$scrollToIndex","align","itemOffset","$fixScrollJump","range","isScrolling","totalSize","onMounted","container","raf","requestAnimationFrame","assignScrollableElement","parentElement","onUnmounted","cancelAnimationFrame","count","immediate","scrollSize","getScrollSize","findItemIndex","scrollToIndex","scrollBy","ItemElement","total","items","renderItem","L","W","Y","D","X","U","K","G","Z","ee","mounted","overflowAnchor","flex","width","height","pointerEvents","VList","handle","args","WindowVirtualizer","createWindowResizer","windowSizeKey","cleanupOnWindowResize","window","onWindowResize","createWindowScroller","containerElement","scrollToKey","calcOffsetToViewport","offsetKey","offsetSum","innerWidth","offsetWidth","parent","body","html","getScrollbarSize","clientWidth","clientHeight"],"mappings":"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"}